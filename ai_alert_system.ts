/**
 * Advanced AI Alert System
 * Machine learning-powered alert generation and analysis
 */

export interface AlertRule {
  id: string;
  name: string;
  description: string;
  type: 'keyword' | 'pattern' | 'anomaly' | 'correlation';
  conditions: Record<string, any>;
  actions: string[];
  severity: 'low' | 'medium' | 'high' | 'critical';
  enabled: boolean;
  createdAt: Date;
  lastTriggered?: Date;
  triggerCount: number;
}

export interface AlertPattern {
  id: string;
  pattern: string;
  type: 'regex' | 'keyword' | 'semantic';
  confidence: number;
  category: string;
  examples: string[];
  createdAt: Date;
}

export interface AlertCorrelation {
  id: string;
  alerts: string[];
  correlationType: 'temporal' | 'spatial' | 'behavioral';
  confidence: number;
  insights: string[];
  timestamp: Date;
}

export class AIAlertSystem {
  private rules: Map<string, AlertRule> = new Map();
  private patterns: Map<string, AlertPattern> = new Map();
  private correlations: AlertCorrelation[] = [];
  private mlModel: AIModel;

  constructor() {
    this.mlModel = new AIModel();
    this.initializeDefaultRules();
    this.initializeDefaultPatterns();
  }

  private initializeDefaultRules(): void {
    const defaultRules: AlertRule[] = [
      {
        id: 'deepfake_detection',
        name: 'Deepfake Content Detection',
        description: 'Detects AI-generated deepfake content',
        type: 'pattern',
        conditions: {
          contentType: 'image',
          modelSignatures: ['stable_diffusion', 'dall_e', 'midjourney'],
          confidence: { min: 0.8 }
        },
        actions: ['notify_team', 'block_content', 'log_incident'],
        severity: 'high',
        enabled: true,
        createdAt: new Date(),
        triggerCount: 0
      },
      {
        id: 'csa_content',
        name: 'Child Safety Alert',
        description: 'Detects potential child safety violations',
        type: 'keyword',
        conditions: {
          keywords: ['csa', 'child', 'abuse', 'exploitation'],
          contentType: 'any',
          sourceRisk: 'high'
        },
        actions: ['escalate_immediate', 'preserve_evidence', 'notify_authorities'],
        severity: 'critical',
        enabled: true,
        createdAt: new Date(),
        triggerCount: 0
      },
      {
        id: 'bulk_ai_generation',
        name: 'Bulk AI Content Generation',
        description: 'Detects large-scale AI content generation',
        type: 'anomaly',
        conditions: {
          timeWindow: '1h',
          threshold: 100,
          contentType: 'image'
        },
        actions: ['monitor_closely', 'analyze_patterns', 'generate_report'],
        severity: 'medium',
        enabled: true,
        createdAt: new Date(),
        triggerCount: 0
      }
    ];

    defaultRules.forEach(rule => {
      this.rules.set(rule.id, rule);
    });

    console.log(`[AI_ALERT] ðŸ“‹ Initialized ${defaultRules.length} default alert rules`);
  }

  private initializeDefaultPatterns(): void {
    const defaultPatterns: AlertPattern[] = [
      {
        id: 'ai_watermark_pattern',
        pattern: '(?i)(generated by ai|ai generated|stable diffusion|dall-e|midjourney)',
        type: 'regex',
        confidence: 0.9,
        category: 'ai_content',
        examples: ['Generated by AI', 'Stable Diffusion v2', 'DALL-E 3'],
        createdAt: new Date()
      },
      {
        id: 'deepfake_indicators',
        pattern: '(?i)(face swap|deep fake|manipulated|altered)',
        type: 'regex',
        confidence: 0.85,
        category: 'deepfake',
        examples: ['Face swapped', 'Deep fake detected', 'Image manipulated'],
        createdAt: new Date()
      },
      {
        id: 'abuse_keywords',
        pattern: '(?i)(abuse|exploitation|harassment|threat)',
        type: 'regex',
        confidence: 0.8,
        category: 'safety',
        examples: ['Child abuse', 'Exploitation content', 'Harassment detected'],
        createdAt: new Date()
      }
    ];

    defaultPatterns.forEach(pattern => {
      this.patterns.set(pattern.id, pattern);
    });

    console.log(`[AI_ALERT] ðŸŽ¯ Initialized ${defaultPatterns.length} detection patterns`);
  }

  async processContent(content: any): Promise<any[]> {
    console.log(`[AI_ALERT] ðŸ” Processing content for alerts: ${content.id || 'unknown'}`);

    const alerts: any[] = [];

    // Check all enabled rules
    for (const rule of this.rules.values()) {
      if (!rule.enabled) continue;

      const matches = await this.checkRuleMatch(rule, content);
      if (matches) {
        const alert = await this.generateAlert(rule, content, matches);
        alerts.push(alert);

        // Update rule statistics
        rule.lastTriggered = new Date();
        rule.triggerCount++;
      }
    }

    // Generate correlations
    if (alerts.length > 1) {
      const correlation = await this.generateCorrelation(alerts, content);
      this.correlations.push(correlation);
    }

    return alerts;
  }

  private async checkRuleMatch(rule: AlertRule, content: any): Promise<any> {
    switch (rule.type) {
      case 'keyword':
        return this.checkKeywordMatch(rule, content);
      case 'pattern':
        return this.checkPatternMatch(rule, content);
      case 'anomaly':
        return this.checkAnomalyMatch(rule, content);
      case 'correlation':
        return this.checkCorrelationMatch(rule, content);
      default:
        return null;
    }
  }

  private checkKeywordMatch(rule: AlertRule, content: any): any {
    const keywords = rule.conditions.keywords || [];
    const contentText = this.extractTextContent(content);

    for (const keyword of keywords) {
      if (contentText.toLowerCase().includes(keyword.toLowerCase())) {
        return { matchedKeyword: keyword, confidence: 0.9 };
      }
    }

    return null;
  }

  private async checkPatternMatch(rule: AlertRule, content: any): Promise<any> {
    const contentText = this.extractTextContent(content);
    const matches: any[] = [];

    for (const pattern of this.patterns.values()) {
      try {
        const regex = new RegExp(pattern.pattern, 'gi');
        const found = contentText.match(regex);

        if (found) {
          matches.push({
            patternId: pattern.id,
            matches: found,
            confidence: pattern.confidence
          });
        }
      } catch (error) {
        console.warn(`[AI_ALERT] Invalid pattern ${pattern.id}:`, error);
      }
    }

    return matches.length > 0 ? { patterns: matches } : null;
  }

  private checkAnomalyMatch(rule: AlertRule, content: any): any {
    // Check for anomalous patterns
    const timeWindow = rule.conditions.timeWindow || '1h';
    const threshold = rule.conditions.threshold || 10;

    // Mock anomaly detection - in real implementation would analyze historical data
    const anomalyScore = Math.random();

    if (anomalyScore > 0.8) {
      return { anomalyScore, threshold, timeWindow };
    }

    return null;
  }

  private checkCorrelationMatch(rule: AlertRule, content: any): any {
    // Check for correlations between different alerts
    const recentCorrelations = this.correlations.slice(-10);
    const relatedAlerts = recentCorrelations.flatMap(c => c.alerts);

    // Mock correlation logic
    if (relatedAlerts.length > 3) {
      return { correlatedAlerts: relatedAlerts.slice(-3) };
    }

    return null;
  }

  private extractTextContent(content: any): string {
    // Extract text content from various content types
    if (typeof content === 'string') return content;
    if (content.text) return content.text;
    if (content.description) return content.description;
    if (content.title) return content.title;

    // For images, use metadata or OCR results
    if (content.metadata) {
      return JSON.stringify(content.metadata);
    }

    return '';
  }

  private async generateAlert(rule: AlertRule, content: any, matches: any): Promise<any> {
    return {
      id: `alert_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      ruleId: rule.id,
      ruleName: rule.name,
      severity: rule.severity,
      contentId: content.id || 'unknown',
      matches,
      timestamp: new Date(),
      actions: rule.actions,
      confidence: this.calculateAlertConfidence(matches)
    };
  }

  private calculateAlertConfidence(matches: any): number {
    if (Array.isArray(matches)) {
      const avgConfidence = matches.reduce((sum: number, match: any) =>
        sum + (match.confidence || 0), 0) / matches.length;
      return Math.min(avgConfidence, 1.0);
    }

    return matches.confidence || 0.5;
  }

  private async generateCorrelation(alerts: any[], content: any): Promise<AlertCorrelation> {
    return {
      id: `correlation_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      alerts: alerts.map(a => a.id),
      correlationType: 'temporal',
      confidence: 0.8,
      insights: [
        'Multiple alerts triggered in short time window',
        'Similar content patterns detected',
        'Potential coordinated activity'
      ],
      timestamp: new Date()
    };
  }

  async addRule(rule: Omit<AlertRule, 'id' | 'createdAt' | 'triggerCount'>): Promise<string> {
    const newRule: AlertRule = {
      ...rule,
      id: `rule_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      createdAt: new Date(),
      triggerCount: 0
    };

    this.rules.set(newRule.id, newRule);
    console.log(`[AI_ALERT] âž• Added new rule: ${newRule.name}`);

    return newRule.id;
  }

  async addPattern(pattern: Omit<AlertPattern, 'id' | 'createdAt'>): Promise<string> {
    const newPattern: AlertPattern = {
      ...pattern,
      id: `pattern_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      createdAt: new Date()
    };

    this.patterns.set(newPattern.id, newPattern);
    console.log(`[AI_ALERT] âž• Added new pattern: ${newPattern.pattern}`);

    return newPattern.id;
  }

  async testRule(ruleId: string, testContent: any): Promise<any> {
    const rule = this.rules.get(ruleId);
    if (!rule) {
      throw new Error(`Rule ${ruleId} not found`);
    }

    const matches = await this.checkRuleMatch(rule, testContent);
    const wouldTrigger = matches !== null;

    return {
      ruleId,
      wouldTrigger,
      matches,
      confidence: matches ? this.calculateAlertConfidence(matches) : 0
    };
  }

  getAlertStats(): Record<string, any> {
    const rules = Array.from(this.rules.values());
    const patterns = Array.from(this.patterns.values());

    return {
      totalRules: rules.length,
      enabledRules: rules.filter(r => r.enabled).length,
      totalPatterns: patterns.length,
      totalCorrelations: this.correlations.length,
      topTriggeredRules: rules
        .sort((a, b) => b.triggerCount - a.triggerCount)
        .slice(0, 5)
        .map(r => ({ id: r.id, name: r.name, triggers: r.triggerCount }))
    };
  }

  async optimizeRules(): Promise<void> {
    console.log('[AI_ALERT] ðŸŽ¯ Optimizing alert rules with ML');

    // Use AI model to optimize rules based on historical performance
    for (const rule of this.rules.values()) {
      const optimization = await this.mlModel.optimizeRule(rule);
      if (optimization.confidence > rule.conditions.confidence?.min || 0) {
        rule.conditions = { ...rule.conditions, ...optimization };
        console.log(`[AI_ALERT] âœ… Optimized rule: ${rule.name}`);
      }
    }
  }
}

/**
 * AI Model for Alert Optimization
 */
class AIModel {
  async optimizeRule(rule: AlertRule): Promise<Record<string, any>> {
    // Mock AI optimization - in real implementation would use ML models
    return {
      confidence: { min: Math.min((rule.conditions.confidence?.min || 0.5) + 0.1, 0.95) },
      additionalKeywords: ['optimized', 'ai_enhanced']
    };
  }

  async predictAlertProbability(content: any): Promise<number> {
    // Mock prediction - in real implementation would use trained ML model
    return Math.random();
  }
}

export const aiAlertSystem = new AIAlertSystem();
